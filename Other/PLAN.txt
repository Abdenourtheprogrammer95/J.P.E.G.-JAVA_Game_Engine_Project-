<Section 1: JAVA implementation>
The players, mobs and should implement the interfaces "has_health_points" and "can_move".
	And since they're considered entities, it seems natural for them to inherit from the abstract class "Entity".
		Each entity will drop a certain amount of xp (experience orbs), determined by its rarity.
The immutable blocks, walls, and any other inanimated element of the scene should implement the interface "has_a_fixed_position" and "immutable".
	Specifically, the blocks should be breakable (so that the player may find bonuses by scavenging them).
_______________________
<Section 2: Game rules>
* If the player doesn't sleep upon level execution, phantoms will start disturbing him but only after 3 repeated night skips.
* Each entity will drop a specific item post-death, which will help the player improve their gear.
* An increasingly big number of entities to defeat are going to randomly generate each level.
	Their position is random, their total number and/or hp isn't.
__________________________________
<Section 3: Brainstorming (kinda)>
1) How could we implement the player's gear improve?
--- Well, I think it's simple: all we have to do is update his weapon damage and armor resistance values.
> private (for encapsulation) static (two players start at the same level) weapon_damage;
> private static armor_resistance; (same explanation)
We then increment each 1 of the 2 attributes, following player interactions.

2) What about the walls, how to make them indestructible?
--- My first thought had been to give it a private wall_health attribute with a ridiculously big value (like 999,999,999):
> private static int wall_health = 999999999;
--- But I quickly changed my mind and decided to make its value -1.
	That way, it will keep ENDLESSLY decrementing each time it's hit.
		And, I'm sure you guessed it, the condition "if (wall_health=0) {bla bla}" will never be true.
> private static int wall_health = -1;
--- Or, we could just make the attribute final, and adapt the way the player hits it.
> private static final int wall_health;

3) How are we going to implement the sleep mechanics, and more broadly, how will we animate the player?
--- For the sleep mechanics issue, I'm thinking we could calculate the distance between the player and the bed.
	Remember, the bed only shows up at the last level of current world (yes, we're implementing different worlds/dimensions like in the real minecraft).
		So when that happens, if there are no more entities left, and the player is close enough to the bed, it will trigger two buttons (Yes & No).
			You'll then have to choose by clicking one of them.
--- Whether it's about the entities, the boxes or anything that's constantly evolving or moving, sprites are going to be the life-savers.
	Reminder: A sprite (not the drink), in video games, is a two-dimensional image or animation in computer graphics.
		The more sprites we stack, the more precise and fluid are going to be the movements.

4) What will our reward system look like?
--- Each entity drops a specific item (check Section_2 above):
Enderman -> enderpearl
Creeper -> gunpowder
Skeleton -> bone / arrow
Zombie -> rotten flesh / potato / carrot / iron ingot
Phantom -> phantom membrane
Cave Spider -> string / spider eye
--- IF and WHEN the player has enough xp, he can improve his gear, using:
* string/bone to augment his bow damage:
	> private static double bow_damage;
	  bow_damage += ((string+bone)/2)*0.09;
* arrow to expand his quiver, this way:
	> private static int quiver;
	  quiver += arrow;
* enderpearl to make him move quicker:
	> private static double player_speed;
	  player_speed = 1.0 + enderpearl;
// with 1.0 being the base speed

5) Concerning the player/entity movements:
--- The player can move freely at the currently set speed (check previous point).
	ZQSD or directional arrows will be used as keyboard input (to know more about it, check PracticalSession_4 by Leturc).
		The unit will be pixels.
--- The hostile mobs will move following a pattern: they chase the player.
	> while (mob_position-player_position >= min_value) {
	// public method that sets the mob in motion
		  mob.move() {...}
	  }

	Endermen are the only entitites able to teleport:
	// Enderman class ...
		> if (player.hit(enderman)) {
			  enderman_position = player_position+min_value+random_number;
		  }